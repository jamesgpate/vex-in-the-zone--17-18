#pragma config(Sensor, dgtl1,  ldtEnc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rdtEnc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  ldr4bEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  rdr4bEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, fourbarEnc,     sensorQuadEncoder)
#pragma config(Motor,  port1,           mgmr,          tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           fourbar,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           ldr4b,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ldt1,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           ldt2,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           rdt1,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rdt2,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rdr4b,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           claw,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          mgml,          tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Sensor, dgtl5,  data,           sensorDigitalOut)
//#pragma config(Sensor, dgtl6,  clock,          sensorDigitalOut)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#pragma platform(VEX2)

#include "Vex_Competition_Includes.c"
#include "driving.c"
#include "auton.c"
//#include "lights.c"
struct gyroConfig{
	float stdDev;
	float avg;
	float voltsPerDPS;
	char gyroFlipped;
};
typedef struct {
	struct gyroConfig config;
	int portNum;
} Gyro;
#define GYRO_STD_DEVS 3
#define GYRO_OVERSAMPLE 1
#define GYRO_CALIBRATION_POINTS 2000
float calibrationBuffer [GYRO_CALIBRATION_POINTS];
float gyroGetRate (Gyro gyro);
void gyroCalibrate (Gyro gyro){
	float rawAverage = 0.0;
	float stdDev = 0.0;
	//calculate average gyro reading with no motion
	for(int i = 0; i < GYRO_CALIBRATION_POINTS; ++i){
		float raw = SensorValue (gyro.portNum);
		rawAverage += raw;
		calibrationBuffer [i] = raw;
		delay (1);
	}
	rawAverage /= GYRO_CALIBRATION_POINTS;
	gyro.config.avg = rawAverage;
	//calcuate the standard devation, or the average distance
	//from the average on the data read
	for (int i = 0; i < GYRO_CALIBRATION_POINTS; ++i)
		stdDev += fabs (rawAverage - calibrationBuffer [i]);
	stdDev /= (float) GYRO_CALIBRATION_POINTS;
	gyro.config.stdDev = stdDev;
	gyro.config.voltsPerDPS = 0.0011 * 1.515;
}
void gyroInit (Gyro gyro, int portNum, char gyroFlipped) {
	gyro.portNum = portNum;
	gyro.config.gyroFlipped = gyroFlipped;
	gyroCalibrate (gyro);
}
float gyroGetRate (Gyro gyro){
	float gyroRead = 0.0;

	#if defined (GYRO_OVERSAMPLE)
		if (GYRO_OVERSAMPLE > 0) {
			int sampleSum = 0;
			int nSamples = pow (4, GYRO_OVERSAMPLE);

			for (int i = 0; i < nSamples; ++i)
				sampleSum += SensorValue(gyro.portNum);
			gyroRead = (float) sampleSum / (float) nSamples;
		}
		else
			gyroRead = SensorValue (gyro.portNum);
	#else
		gyroRead = SensorValue (gyro.portNum);
	#endif
	float gyroDiff = gyroRead - gyro.config.avg;
	float gyroVoltage = gyroDiff * 5.0 / 4095.0;

	if (fabs (gyroDiff) > GYRO_STD_DEVS * gyro.config.stdDev)
		if (gyro.config.gyroFlipped)
			return -1 * gyroVoltage / gyro.config.voltsPerDPS;
		else
			return gyroVoltage / gyro.config.voltsPerDPS;
	return 0;
}
Gyro gyro1, gyro2;
gyroInit(gyro1,1,1);
gyroInit(gyro2,2,1);
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

void waitForRelease()
{
	while(nLCDButtons != 0)
		wait1Msec(5);
}
void waitForPress()
{
	while(nLCDButtons == 0)
		wait1Msec(5);
}
void pre_auton(){//Selects auton program
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	playTone(440,10);
	wait1Msec(100);
	playTone(660,10);
	while(nLCDButtons != centerButton){
		switch(lcdCount){
		case 0:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0,0, firstAutonString);
			displayLCDString(1,0, enterString);
			waitForPress();
			if(nLCDButtons == leftButton){
				waitForRelease();
				lcdCount = 3;
			}
			else if(nLCDButtons == rightButton){
				waitForRelease();
				lcdCount++;
			}
			SensorValue[rdr4bEnc]=0;
			SensorValue[ldr4bEnc]=0;
			SensorValue[fourbarEnc]=0;
		break;
		case 1:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0,0, secondAutonString);
			displayLCDString(1,0, enterString);
			waitForPress();
			if(nLCDButtons == leftButton){
				waitForRelease();
				lcdCount--;
			}
			else if(nLCDButtons == rightButton){
				waitForRelease();
				lcdCount++;
			}
			SensorValue[rdr4bEnc]=0;
			SensorValue[ldr4bEnc]=0;
			SensorValue[fourbarEnc]=0;
			break;
		case 2:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0,0, thirdAutonString);
			displayLCDString(1,0, enterString);
			waitForPress();
			if(nLCDButtons == leftButton){
				waitForRelease();
				lcdCount--;
			}
			else if(nLCDButtons == rightButton){
				waitForRelease();
				lcdCount++;
			}
			SensorValue[rdr4bEnc]=0;
			SensorValue[ldr4bEnc]=0;
			SensorValue[fourbarEnc]=0;
			break;
		case 3:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0,0, fourthAutonString);
			displayLCDString(1,0, enterString);
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				lcdCount--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				lcdCount = 0;
			}
			SensorValue[rdr4bEnc]=0;
			SensorValue[ldr4bEnc]=0;
			SensorValue[fourbarEnc]=0;
			break;
		default:
			lcdCount = 0;
			SensorValue[rdr4bEnc]=0;
			SensorValue[ldr4bEnc]=0;
			SensorValue[fourbarEnc]=0;
			break;
		}
		SensorValue[ldtEnc]=0;
		SensorValue[rdtEnc]=0;
	}
}
task autonomous(){
	startTask(auton);
}
task usercontrol(){
	startTask(drive);
}
